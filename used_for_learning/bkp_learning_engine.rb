require 'rmagick'
require 'ruby-fann'
include Magick

BASE_DIR        = "/home/Projects/neural_network_project"
DIGITS_DIR      = "#{BASE_DIR}/Digits"
LIB_DIR         = "#{BASE_DIR}/lib"
JPGS_DIR        = "#{DIGITS_DIR}/jpgs"
CONVERTED_DIR   = "#{DIGITS_DIR}/converted"

FOR_TESTING_DIR           = "#{JPGS_DIR}/notLearned"
FOR_TESTING_CONVERTED_DIR = "#{CONVERTED_DIR}/notLearned"

def convert_images_for_trainning
  (0..9).each do |digit|
    cont = 0
    jpg_images = Dir["#{JPGS_DIR}/#{digit}/*.jpg"]

    jpg_images.each do |filepath|
      new_filepath = "#{CONVERTED_DIR}/#{digit}/#{cont}.png"
      rmagick_image = ImageList.new("#{filepath}").resize_to_fit(50, 50)
      rmagick_image.write(new_filepath)
      @all_images << new_filepath
      cont += 1
    end
  end
end

def convert_images_for_testing
  cont = 0
  images = Dir["#{FOR_TESTING_DIR}/*.jpg"]

  images.each do |filepath|
    filename = filepath.match(/\/(.)\.jpg/) { $1 }
    puts filename
    new_filepath = "#{FOR_TESTING_CONVERTED_DIR}/#{filename}.png"
    rmagick_image = ImageList.new("#{filepath}").resize_to_fit(50, 50)
    rmagick_image.write(new_filepath)
    @all_images_for_testing << new_filepath
    cont += 1
  end
end

def create_array_of_arrays_trainning
  @all_images.each_with_index do |image, idx|
    puts ("#{idx}#{image}")
    
    rmagick_image = ImageList.new(image)
    image_pixels = []

    rmagick_image.each_pixel do |px, x, y|
      if px.red == 0 # && px.green == 0 && px.blue == 0
        image_pixels << 1
      else
        image_pixels << 0
      end
    end
    @input_arrays << image_pixels
  end
end

def create_array_of_arrays_testing
  @all_images_for_testing.each_with_index do |image, idx|
    puts ("#{idx}#{image}")
    
    rmagick_image = ImageList.new(image)
    image_pixels = []

    rmagick_image.each_pixel do |px, x, y|
      if px.red == 0 # && px.green == 0 && px.blue == 0
        image_pixels << 1
      else
        image_pixels << 0
      end
    end
    @testing_input_arrays << image_pixels
  end
end


@all_images = []
# Convert images
convert_images_for_trainning
puts 'Status: images converted'
puts "all_images size = #{@all_images.size}"

# Prepare inputs for Neural Network
@input_arrays = []
create_array_of_arrays_trainning

#
@all_images_for_testing = []
convert_images_for_testing

#
@testing_input_arrays = []
create_array_of_arrays_testing

RubyFann::TrainData.new(:filename => "#{LIB_DIR}/training_file.train")

train = RubyFann::TrainData.new(
  inputs: @input_arrays,
  desired_outputs: [
    # Digit 0
    [1,0,0,0,0,0,0,0,0,0], [1,0,0,0,0,0,0,0,0,0], [1,0,0,0,0,0,0,0,0,0],
    [1,0,0,0,0,0,0,0,0,0], [1,0,0,0,0,0,0,0,0,0], [1,0,0,0,0,0,0,0,0,0],
    [1,0,0,0,0,0,0,0,0,0], [1,0,0,0,0,0,0,0,0,0], [1,0,0,0,0,0,0,0,0,0],
    [1,0,0,0,0,0,0,0,0,0], [1,0,0,0,0,0,0,0,0,0], [1,0,0,0,0,0,0,0,0,0],
    [1,0,0,0,0,0,0,0,0,0], [1,0,0,0,0,0,0,0,0,0], [1,0,0,0,0,0,0,0,0,0],
    [1,0,0,0,0,0,0,0,0,0], [1,0,0,0,0,0,0,0,0,0], [1,0,0,0,0,0,0,0,0,0],
    [1,0,0,0,0,0,0,0,0,0], [1,0,0,0,0,0,0,0,0,0],
    # Digit 1
    [0,1,0,0,0,0,0,0,0,0], [0,1,0,0,0,0,0,0,0,0], [0,1,0,0,0,0,0,0,0,0],
    [0,1,0,0,0,0,0,0,0,0], [0,1,0,0,0,0,0,0,0,0], [0,1,0,0,0,0,0,0,0,0],
    [0,1,0,0,0,0,0,0,0,0], [0,1,0,0,0,0,0,0,0,0], [0,1,0,0,0,0,0,0,0,0],
    [0,1,0,0,0,0,0,0,0,0], [0,1,0,0,0,0,0,0,0,0], [0,1,0,0,0,0,0,0,0,0],
    [0,1,0,0,0,0,0,0,0,0], [0,1,0,0,0,0,0,0,0,0], [0,1,0,0,0,0,0,0,0,0],
    [0,1,0,0,0,0,0,0,0,0], [0,1,0,0,0,0,0,0,0,0], [0,1,0,0,0,0,0,0,0,0],
    [0,1,0,0,0,0,0,0,0,0], [0,1,0,0,0,0,0,0,0,0],
    # Digit 2
    [0,0,1,0,0,0,0,0,0,0], [0,0,1,0,0,0,0,0,0,0], [0,0,1,0,0,0,0,0,0,0],
    [0,0,1,0,0,0,0,0,0,0], [0,0,1,0,0,0,0,0,0,0], [0,0,1,0,0,0,0,0,0,0],
    [0,0,1,0,0,0,0,0,0,0], [0,0,1,0,0,0,0,0,0,0], [0,0,1,0,0,0,0,0,0,0],
    [0,0,1,0,0,0,0,0,0,0], [0,0,1,0,0,0,0,0,0,0], [0,0,1,0,0,0,0,0,0,0],
    [0,0,1,0,0,0,0,0,0,0], [0,0,1,0,0,0,0,0,0,0], [0,0,1,0,0,0,0,0,0,0],
    [0,0,1,0,0,0,0,0,0,0], [0,0,1,0,0,0,0,0,0,0], [0,0,1,0,0,0,0,0,0,0],
    [0,0,1,0,0,0,0,0,0,0], [0,0,1,0,0,0,0,0,0,0],
    # Digit 3
    [0,0,0,1,0,0,0,0,0,0], [0,0,0,1,0,0,0,0,0,0], [0,0,0,1,0,0,0,0,0,0],
    [0,0,0,1,0,0,0,0,0,0], [0,0,0,1,0,0,0,0,0,0], [0,0,0,1,0,0,0,0,0,0],
    [0,0,0,1,0,0,0,0,0,0], [0,0,0,1,0,0,0,0,0,0], [0,0,0,1,0,0,0,0,0,0],
    [0,0,0,1,0,0,0,0,0,0], [0,0,0,1,0,0,0,0,0,0], [0,0,0,1,0,0,0,0,0,0],
    [0,0,0,1,0,0,0,0,0,0], [0,0,0,1,0,0,0,0,0,0], [0,0,0,1,0,0,0,0,0,0],
    [0,0,0,1,0,0,0,0,0,0], [0,0,0,1,0,0,0,0,0,0], [0,0,0,1,0,0,0,0,0,0],
    [0,0,0,1,0,0,0,0,0,0], [0,0,0,1,0,0,0,0,0,0],
    # Digit 4
    [0,0,0,0,1,0,0,0,0,0], [0,0,0,0,1,0,0,0,0,0], [0,0,0,0,1,0,0,0,0,0],
    [0,0,0,0,1,0,0,0,0,0], [0,0,0,0,1,0,0,0,0,0], [0,0,0,0,1,0,0,0,0,0],
    [0,0,0,0,1,0,0,0,0,0], [0,0,0,0,1,0,0,0,0,0], [0,0,0,0,1,0,0,0,0,0],
    [0,0,0,0,1,0,0,0,0,0], [0,0,0,0,1,0,0,0,0,0], [0,0,0,0,1,0,0,0,0,0],
    [0,0,0,0,1,0,0,0,0,0], [0,0,0,0,1,0,0,0,0,0], [0,0,0,0,1,0,0,0,0,0],
    [0,0,0,0,1,0,0,0,0,0], [0,0,0,0,1,0,0,0,0,0], [0,0,0,0,1,0,0,0,0,0],
    [0,0,0,0,1,0,0,0,0,0], [0,0,0,0,1,0,0,0,0,0],
    # Digit 5
    [0,0,0,0,0,1,0,0,0,0], [0,0,0,0,0,1,0,0,0,0], [0,0,0,0,0,1,0,0,0,0],
    [0,0,0,0,0,1,0,0,0,0], [0,0,0,0,0,1,0,0,0,0], [0,0,0,0,0,1,0,0,0,0],
    [0,0,0,0,0,1,0,0,0,0], [0,0,0,0,0,1,0,0,0,0], [0,0,0,0,0,1,0,0,0,0],
    [0,0,0,0,0,1,0,0,0,0], [0,0,0,0,0,1,0,0,0,0], [0,0,0,0,0,1,0,0,0,0],
    [0,0,0,0,0,1,0,0,0,0], [0,0,0,0,0,1,0,0,0,0], [0,0,0,0,0,1,0,0,0,0],
    [0,0,0,0,0,1,0,0,0,0], [0,0,0,0,0,1,0,0,0,0], [0,0,0,0,0,1,0,0,0,0],
    [0,0,0,0,0,1,0,0,0,0], [0,0,0,0,0,1,0,0,0,0],
    # Digit 6
    [0,0,0,0,0,0,1,0,0,0], [0,0,0,0,0,0,1,0,0,0], [0,0,0,0,0,0,1,0,0,0],
    [0,0,0,0,0,0,1,0,0,0], [0,0,0,0,0,0,1,0,0,0], [0,0,0,0,0,0,1,0,0,0],
    [0,0,0,0,0,0,1,0,0,0], [0,0,0,0,0,0,1,0,0,0], [0,0,0,0,0,0,1,0,0,0],
    [0,0,0,0,0,0,1,0,0,0], [0,0,0,0,0,0,1,0,0,0], [0,0,0,0,0,0,1,0,0,0],
    [0,0,0,0,0,0,1,0,0,0], [0,0,0,0,0,0,1,0,0,0], [0,0,0,0,0,0,1,0,0,0],
    [0,0,0,0,0,0,1,0,0,0], [0,0,0,0,0,0,1,0,0,0], [0,0,0,0,0,0,1,0,0,0],
    [0,0,0,0,0,0,1,0,0,0], [0,0,0,0,0,0,1,0,0,0],
    # Digit 7
    [0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,0,0],
    [0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,0,0],
    [0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,0,0],
    [0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,0,0],
    [0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,0,0],
    [0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,0,0],
    [0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,0,0],
    # Digit 8
    [0,0,0,0,0,0,0,0,1,0], [0,0,0,0,0,0,0,0,1,0], [0,0,0,0,0,0,0,0,1,0],
    [0,0,0,0,0,0,0,0,1,0], [0,0,0,0,0,0,0,0,1,0], [0,0,0,0,0,0,0,0,1,0],
    [0,0,0,0,0,0,0,0,1,0], [0,0,0,0,0,0,0,0,1,0], [0,0,0,0,0,0,0,0,1,0],
    [0,0,0,0,0,0,0,0,1,0], [0,0,0,0,0,0,0,0,1,0], [0,0,0,0,0,0,0,0,1,0],
    [0,0,0,0,0,0,0,0,1,0], [0,0,0,0,0,0,0,0,1,0], [0,0,0,0,0,0,0,0,1,0],
    [0,0,0,0,0,0,0,0,1,0], [0,0,0,0,0,0,0,0,1,0], [0,0,0,0,0,0,0,0,1,0],
    [0,0,0,0,0,0,0,0,1,0], [0,0,0,0,0,0,0,0,1,0],
    # Digit 9
    [0,0,0,0,0,0,0,0,0,1], [0,0,0,0,0,0,0,0,0,1], [0,0,0,0,0,0,0,0,0,1],
    [0,0,0,0,0,0,0,0,0,1], [0,0,0,0,0,0,0,0,0,1], [0,0,0,0,0,0,0,0,0,1],
    [0,0,0,0,0,0,0,0,0,1], [0,0,0,0,0,0,0,0,0,1], [0,0,0,0,0,0,0,0,0,1],
    [0,0,0,0,0,0,0,0,0,1], [0,0,0,0,0,0,0,0,0,1], [0,0,0,0,0,0,0,0,0,1],
    [0,0,0,0,0,0,0,0,0,1], [0,0,0,0,0,0,0,0,0,1], [0,0,0,0,0,0,0,0,0,1],
    [0,0,0,0,0,0,0,0,0,1], [0,0,0,0,0,0,0,0,0,1], [0,0,0,0,0,0,0,0,0,1],
    [0,0,0,0,0,0,0,0,0,1], [0,0,0,0,0,0,0,0,0,1]
  ]
)

fann = RubyFann::Standard.new(
  num_inputs: 2500,
  hidden_neurons: [1500],
  num_outputs: 10
)

# fann.learning_rate = 0.5
# fann.momentum = 0.5

fann.train_on_data(train, 10000, 10, 0.001)
fann.save("#{LIB_DIR}/training_file.train")

correct_answers = 0
@testing_input_arrays.each_with_index do |arr, idx|
  outputs = fann.run(arr)
  puts "outputs.size: #{outputs.size}"
  correct_answers += 1 if outputs.each_with_index.max[1] == idx
  
end
